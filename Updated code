.model small
.stack 100h
.data
    company_name db "====================", 0dh, 0ah
                 db "|    ABC Retail    |", 0dh, 0ah
                 db "--------------------", 0dh, 0ah, 0
    newline db 0dh,0ah,"$"
    username db "admin", 0
    password db "password", 0
    product db "Shampoo, 15.99", 0
            db "Tissue, 1.99", 0
            db "Hair Gel, 15.99", 0
            db "Lotion, 10.99", 0
    input_buffer db 20, ?, 20 dup(0)
    prompt_user db "Enter username: $"
    prompt_pass db "Enter password: $"
    msg_success db "Login successful!$"
    msg_failure db "Login failed. Try again.$"
    msg_attempts db "Too many failed attempts. Exiting...$"
    attempts db 3  ; Counter for login attempts

.code

main proc
    mov ax, @data
    mov ds, ax

    call login

    mov ax, 4C00h
    int 21h


main endp

login proc
    mov ax, @data
    mov ds, ax

    ; Display store name
    ;mov ah, 09h
    ;lea dx, company_name
    ;int 21h

    ;Display colored store name
    call display_company_colour_name

login_loop:
    ; Check if attempts are exhausted
    cmp attempts, 0
    je too_many_attempts

    ; Prompt for username
    mov ah, 09h
    lea dx, prompt_user
    int 21h

    ; Get username input
    mov ah, 0Ah
    lea dx, input_buffer
    int 21h

    ; Print newline
    mov ah, 09h
    lea dx, newline
    int 21h

    ; Compare username
    mov si, offset username
    lea di, input_buffer + 2
    call compare_strings
    jnz login_failed

    ; Prompt for password
    mov ah, 09h
    lea dx, prompt_pass
    int 21h

    ; Get password input
    mov ah, 0Ah
    lea dx, input_buffer
    int 21h

    ; Print newline
    mov ah, 09h
    lea dx, newline
    int 21h

    ; Compare password
    mov si, offset password
    lea di, input_buffer + 2
    call compare_strings
    jnz login_failed

    ; Call success_login_menu procedure
    call success_login_menu
    jmp exit

login_failed:
    mov ah, 09h
    lea dx, msg_failure
    int 21h

    ; Print newline
    mov ah, 09h
    lea dx, newline
    int 21h

    ; Decrease attempts counter
    dec attempts
    jmp login_loop

too_many_attempts:
    mov ah, 09h
    lea dx, msg_attempts
    int 21h

exit:
    mov ax, 4C00h
    int 21h

login endp

display_company_colour_name proc
    ; Save registers to preserve their original values
    push ax
    push bx
    push cx
    push dx
    push si

    ; Set video mode to standard 80x25 text mode (just in case)
    mov ah, 00h
    mov al, 03h
    int 10h

    ; Set up for colored text display
    mov bl, 3            ; Text color: cyan (3) on black background (0)

    mov si, offset company_name  ; Point SI to the start of company_name string
    mov dh, 0            ; Start at row 0
    mov dl, 0            ; Start at column 0

    ; Start displaying characters
company_name_loop:
    lodsb                ; Load next character from [SI] into AL and increment SI

    cmp al, 0            ; Check for end of string (null terminator)
    je done              ; If end of string, exit the loop

    cmp al, 0Dh          ; Check if the character is a carriage return (ASCII code 0Dh)
    je skip_char         ; If carriage return, skip to next character

    cmp al, 0Ah          ; Check if the character is a newline (ASCII code 0Ah)
    jne print_char       ; If not a newline, proceed to print the character

    ; Handle newline character
    inc dh               ; Move cursor to next row
    mov dl, 0            ; Reset cursor to first column
    jmp set_cursor

print_char:
    ; Print the character with color
    mov ah, 09h          ; BIOS function to write character and attribute
    mov bh, 0            ; Display page number (0)
    mov cx, 1            ; Number of times to print the character (once)
    int 10h              ; Call BIOS interrupt to display the character

    inc dl               ; Move cursor to next column

set_cursor:
    mov ah, 02h          ; Set cursor position
    mov bh, 0            ; Page number
    int 10h              ; Call BIOS interrupt to set new position

skip_char:
    jmp company_name_loop       ; Continue with the next character

done:
    ; Restore registers to their original values
    pop si
    pop dx
    pop cx
    pop bx
    pop ax
    ret                  ; Return from the procedure
display_company_colour_name endp




success_login_menu proc
    mov ah, 06h  ; scroll up function
    mov al, 0    ; clear entire screen
    mov bh, 07h  ; attribute (white on black)
    mov cx, 0    ; start at row 0, column 0
    mov dh, 24   ; end at row 24 (bottom of screen)
    mov dl, 79   ; end at column 79 (right edge of screen)
    int 10h      ; execute BIOS video interrupt

    ; Login successful
    mov ah, 09h
    lea dx, msg_success
    int 21h
success_login_menu endp

compare_strings proc ; COMPARE TWO STRINGS
    push cx
    mov cl, [di-1]  ; get length of input
    xor ch, ch
compare_loop:
    mov al, [si]
    cmp al, [di]
    jne compare_end
    test al, al  ; check for null terminator
    jz compare_match
    inc si
    inc di
    loop compare_loop
compare_match:
    pop cx
    xor ax, ax  ; Clear ZF (set to 0 for match)
    ret
compare_end:
    pop cx
    or ax, ax  ; Set ZF to 1 for no match
    ret
compare_strings endp

end main
